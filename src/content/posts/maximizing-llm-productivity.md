---
title: "Using Coding Assistants Effectively"
pubDate: 2025-01-20
author: "Adam Bossy-Mendoza"
showToc: false
emoji: "⚙️"
description: "A practical guide to leveraging LLMs effectively in your engineering workflow, based on a year of experience with Copilot and Cursor."
---

I'm surprised when I hear software engineers doubt the productivity benefits of LLMs. If applied correctly, the gains can be extraordinary.

Here's what I'd teach my team about maximizing productivity with LLMs, based on how Copilot and Cursor have transformed my workflow over the past year:

![Productivity visualization](https://res.cloudinary.com/dwt45tvzy/image/upload/v1740600495/matrix-code-2_dvhost.jpg)

### You Can Squeeze Changes into Shorter Time Windows Than Ever Before

Finding long blocks of uninterrupted time is one of an engineer's biggest challenges. Much of our work involves rote character editing since machines require every detail to be precise. Tools like Cursor handle these tasks in seconds, letting me focus on the critical thinking part of the problem.

### You Can Solve Problems Without Slogging Through Documentation

Integrating libraries, crafting complex ORM queries, or debugging regexes often means slogging through documentation. With LLMs, these tasks are no longer a time sink.

They excel at instantly solving problems that don't require deep system knowledge but would otherwise consume entire afternoons. I can also build expertise by asking questions about the code they produce, skipping unnecessary reading while building the same knowledge.

### They're Not Software Architects — and That's Okay

LLMs can't replicate the intuition or decision-making depth needed for high-level reasoning. Their effectiveness depends on my ability to provide clear instructions and context.

### Don't Lose Control of Complexity

I'm often tempted to let Cursor run free without understanding its output. But when something breaks, untangling unfamiliar code becomes a time sink. Stay engaged by breaking problems into smaller pieces and review results frequently to prevent this from happening.

LLMs tend to expand functions and add unnecessary complexity. I often prompt them to decompose functions, clean up code, and simplify logic — tasks they handle well when explicitly directed. If they get things wrong, their fixes can spiral into a "doom loop" of escalating complexity. When that happens, it's often faster to start fresh.

### You're Still the Ultimate Arbiter

At the end of the day, I hold the full context of my system's architecture, codebase, customers, and stakeholders. Achieving business results involves intuition, trade-offs, and priorities based on information that LLMs simply don't have. LLMs can assist, but they can't replicate the human brain's ability to weave together all this context and make informed decisions.

### Final Thoughts

After more than a year using Copilot and Cursor, I'm convinced AI isn't just hype — but it won't replace capable engineers. It's raised the productivity bar, while also making my work more *enjoyable* by reducing time spent on tedious tasks like reading documentation or scouring Stack Overflow. By treating LLMs as collaborators, not crutches, we can amplify our work while staying in control of the systems we design.